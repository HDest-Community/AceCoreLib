version "4.5"

class AceCore play
{
	static void Tether(Actor puller, Actor other)
	{
		other.A_Face(puller, 0, 0);
		other.A_ChangeVelocity(1, 0, -1 * sin(other.pitch), CVF_RELATIVE | CVF_REPLACE);
		vector3 dir = puller.Vec3To(other);
		dir.z -= puller.height / 4;
		vector3 unit = dir.unit();
		for (double i = 0; i < puller.Distance3D(other); i += 0.75)
		{
			puller.A_SpawnParticle(0x00CCCC, SPF_FULLBRIGHT, 1, 1.5, 0, unit.x * i, unit.y * i, puller.height / 2 + unit.z * i);
		}
	}

	static clearscope int GetRealBatteryCharge(int curBattery, double div, bool useUpper)
	{
		if (curBattery == -1)
		{
			return -1;
		}
		double FracCharge = curBattery / div;
		return int(useUpper ? ceil(FracCharge) : floor(FracCharge));
	}

	static clearscope string, int, Color GetBatteryColor(int charge)
	{
		if (charge > 13)
		{
			return "CELLA0", Font.CR_GREEN, Color(255, 0, 255, 0);
		}
		else if (charge > 6)
		{
			return "CELLB0", Font.CR_YELLOW, Color(255, 255, 255, 0);
		}
		else if (charge > 0)
		{
			return "CELLC0", Font.CR_RED, Color(255, 255, 0, 0);
		}
		else
		{
			return "CELLD0", Font.CR_GRAY, Color(255, 64, 64, 64);
		}
	}

	static clearscope string GetIcon(Inventory item, int magAmt = -1, bool invIconFirst = false)
	{
		string Icon = "";
		let wpn = HDWeapon(item);
		let arm = HDArmour(item);
		let mag = HDMagAmmo(item);

		if (!invIconFirst)
		{
			if (wpn)
			{
				Icon = wpn.GetPickupSprite();
			}
			else if (arm)
			{
				Icon = magAmt >= 1000 ? "ARMCA0" : "ARMSA0";
			}
			else if (mag)
			{
				Icon = mag.GetMagSprite(magAmt > -1 ? magAmt : mag.MaxPerUnit);
			}
		}

		// [Ace] Still empty? Fallback time.
		if (Icon == "")
		{
			Icon = TexMan.GetName(item.Icon);
			if (Icon == "") // [Ace] Persistent bastard, aren't ya?
			{
				Icon = TexMan.GetName(item.SpawnState.GetSpriteTexture(0));

				if (Icon == "")
				{
					Icon = GetIcon(item, magAmt, false);
				}
			}
		}

		return Icon;
	}

	static clearscope int, int GetLowestBattery(HDBattery stack, int minCharge)
	{
		if (stack)
		{
			int LowestIndex = stack.Mags.Size() - 1;
			int LowestCharge = stack.MaxPerUnit;
			for (int i = LowestIndex; i >= 0; --i)
			{
				if (stack.Mags[i] >= minCharge && stack.Mags[i] <= LowestCharge)
				{
					LowestIndex = i;
					LowestCharge = stack.Mags[i];
				}
			}

			// [Ace] Do a final check to see if the battery fulfills the conditions.
			// If there is only one battery and the charge is < minCharge, the loop above won't do much.
			if (stack.Mags[LowestIndex] >= minCharge)
			{
				return LowestIndex, stack.Mags[LowestIndex];
			}
		}

		return -1, 0;
	}

	static clearscope int GetHighestBattery(HDBattery stack, int max)
	{
		int MinCharge = 0, LastIndex = -1; 
		for (int i = 0; i < stack.Mags.Size(); ++i)
		{
			if (stack.Mags[i] >= MinCharge && stack.Mags[i] < max)
			{
				MinCharge = stack.Mags[i];
				LastIndex = i;
			}
		}

		return LastIndex;
	}

	static clearscope bool CheckForItem(Actor other, Name item, int amt = 1)
	{
		class<HDWeapon> cls = item;
		return cls && other && other.CountInv(cls) >= amt;
	}

	static void DrawCollisionBox(Actor a, Color col = 0xFF0000, double density = 0.25, double psize = 0.5)
	{
		// [Ace] Dots.
		a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, 0, 0, a.Height);
		a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, a.Radius, 0, a.Height / 2);
		a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, 0, a.Radius, a.Height / 2);
		a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, 0, 0, a.Height / 2);
		a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, 0, -a.Radius, a.Height / 2);
		a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, -a.Radius, 0, a.Height / 2);
		a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, 0, 0, 0);

		// [Ace] Horizontal lines.
		for (double i = -a.Radius; i <= a.Radius; i += density)
		{
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, a.Radius, i, 0);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, -a.Radius, i, 0);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, i, a.Radius, 0);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, i, -a.Radius, 0);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, a.Radius, i, a.Height);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, -a.Radius, i, a.Height);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, i, a.Radius, a.Height);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, i, -a.Radius, a.Height);
		}

		// [Ace] Vertical lines.
		for (double i = 0; i <= a.Height; i += density)
		{
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, a.Radius, a.Radius, i);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, a.Radius, -a.Radius, i);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, -a.Radius, a.Radius, i);
			a.A_SpawnParticle(col, SPF_FULLBRIGHT, 1, psize, 0, -a.Radius, -a.Radius, i);
		}
	}
	
	static void DrawXYZ(Actor a, double lengthx = 128, Color col = 0xFF0000, bool fromCenter = false)
	{
		for (double i = 0; i < (fromCenter ? a.Height / 2 : a.Height); i += 0.5)
		{
			a.A_SpawnParticle(col, SPF_FULLBRIGHT | SPF_RELATIVE, 1, 2, 0, i * sin(a.pitch), 0, (fromCenter ? a.Height / 2 : 0) + i * cos(a.pitch));
		}
		for (double i = 0; i < a.Radius; i += 0.5)
		{
			a.A_SpawnParticle(col, SPF_FULLBRIGHT | SPF_RELATIVE, 1, 2, 0, 0, i, (fromCenter ? a.Height / 2 : 0));
		}
		for (double i = 0; i < lengthx; i += 0.50)
		{
			a.A_SpawnParticle(col, SPF_FULLBRIGHT | SPF_RELATIVE, 1, 2, 0, i * cos(a.pitch), 0, (fromCenter ? a.Height / 2 : 0) + i * sin(-a.pitch));
		}
	}

	enum LiquidType
	{
		LType_Solid,
		LType_Normal,
		LType_Dissolving
	}

	static const string LiquidTextures[] = { "FWATER", "F_HWATR", "F_PWATR", "P_VWATR", "F_WATR",  "OWATER" "BLOOD", "SLIME", "FLATHUH", "FLTFLWW", "FLTWAWA", "FLTSLUD", "X_", "GRAYSLM", "SLUDGE", "OTAR__", "OBLODA", "OICYWA", "OSLIME", "NUKAGE", "ONUKEA", "LAVA", "FLTLAVA", "OLAVAC", "OLAVAD", "OSLUDG", "OGOOPY" };

	static LiquidType CheckTextureType(Sector sec, string filter = "")
	{
		string FTex = TexMan.GetName(sec.GetTexture(0)).MakeUpper();

		if (filter != "") // [Ace] Search floor texture for a specific combination.
		{
			Array<string> SplitFilter;
			filter = filter.MakeUpper();
			filter.Replace(" ", "");
			filter.Split(SplitFilter, "|");
			for (int i = 0; i < SplitFilter.Size(); ++i)
			{
				if (FTex.IndexOf(SplitFilter[i]) != -1)
				{
					return sec.damageamount > 0 ? LType_Dissolving : LType_Normal;
				}
			}
		}
		else // [Ace] Search against the list above.
		{
			for (int i = 0; i < AceCore.LiquidTextures.Size(); ++i)
			{
				if (FTex.IndexOf(AceCore.LiquidTextures[i]) != -1)
				{
					return sec.damageamount > 0 ? LType_Dissolving : LType_Normal;
				}
			}
		}

		return LType_Solid;
	}
}

class AceCoreHandler : StaticEventHandler
{
	override void NetworkProcess(ConsoleEvent e)
	{
		let plr = players[e.Player].mo;
		if (e.Name ~== "ACL_Ruler")
		{
			plr.A_SpawnItemEx("AceRuler", flags: SXF_NOCHECKPOSITION | SXF_SETMASTER);
		}
	}
}

class AceRuler : Actor
{
	override void Tick()
	{
		if (!master || --ReactionTime <= 0)
		{
			Destroy();
			return;
		}

		double D2D = Distance2D(master);
		double D3D = Distance3D(master);
		master.A_Log(String.Format("Distance2D: %.2f (%.2fm); Distance3D: %.2f (%.2fm)", D2D, D2D / HDCONST_ONEMETRE, D3D, D3D / HDCONST_ONEMETRE));

		Super.Tick();
	}

	Default
	{
		+NOINTERACTION
		ReactionTime 35 * 20;
	}
}